unit TestRedisClientU;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, System.Variants, IdTCPClient, Winapi.Windows, Vcl.Dialogs,
  Vcl.Forms, IdTCPConnection, Vcl.Controls, System.Classes, System.SysUtils,
  IdComponent, Winapi.Messages, IdBaseComponent, Vcl.Graphics, Vcl.StdCtrls,
  Redis.Client, Redis.Commons;

type
  // Test methods for class IRedisClient

  TestRedisClient = class(TTestCase)
  strict private
    FRedis: IRedisClient;
  private
    Res: string;
    ArrRes: TArray<string>;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestCommandParser;
    procedure TestExecuteWithStringArrayResponse;
    procedure TestSetGet;
    procedure TestSetGetUnicode;
    procedure TestAPPEND;
    procedure TestSTRLEN;
    procedure TestGETRANGE;
    procedure TestSETRANGE;
    procedure TestMSET;
    procedure TestINCR_DECR;
    procedure TestEXPIRE;
    procedure TestDelete;
    procedure TestRPUSH_RPOP;
    procedure TestRPUSHX_LPUSHX;
    procedure TestLPUSH_LPOP;
    procedure TestLRANGE;
    procedure TestLLEN;
    procedure TestLTRIM;
    procedure TestZADD_ZRANK_ZCARD;
    procedure TestRPOPLPUSH;
    procedure TestBRPOPLPUSH;
    procedure TestBLPOP;
    procedure TestBRPOP;
    procedure TestLREM;
    procedure TestSELECT;
    procedure TestMULTI;
    procedure TestHSetHGet;
    procedure TestHMSetHMGet;
    procedure TestHMGetBUGWithEmptyValues;
    procedure TestAUTH;
    procedure TestHSetHGet_Bytes;
    procedure TestWATCH_MULTI_EXEC_OK;
    procedure TestWATCH_MULTI_EXEC_Fail;
    procedure TestWATCH_OK;
    procedure TestWATCH_Fail;
    // procedure TestSUBSCRIBE;
  end;

implementation

procedure TestRedisClient.SetUp;
begin
  FRedis := NewRedisClient('localhost', 6379, 'indy');
end;

procedure TestRedisClient.TearDown;
begin
  FRedis := nil;
end;

procedure TestRedisClient.TestAPPEND;
var
  lValue: string;
begin
  FRedis.DEL(['mykey']);
  CheckEquals(4, FRedis.APPEND('mykey', '1234'), 'Wrong length');
  CheckEquals(8, FRedis.APPEND('mykey', '5678'), 'Wrong length');
  CheckTrue(FRedis.GET('mykey', lValue), 'Key doesn''t exist');
  CheckEquals('12345678', lValue, 'Wrong key value...');
end;

procedure TestRedisClient.TestAUTH;
begin
  // the TEST Redis instance is not protected with a password
  ExpectedException := ERedisException;
  FRedis.AUTH('foo');
end;

procedure TestRedisClient.TestBLPOP;
begin
  // setup list
  FRedis.DEL(['mylist']);
  FRedis.RPUSH('mylist', ['one', 'two']);

  // pop from a non-empty list
  CheckTrue(FRedis.BLPOP(['mylist'], 1, ArrRes));
  CheckEquals('mylist', ArrRes[0]);
  CheckEquals('one', ArrRes[1]);

  // pop from a non-empty list
  CheckTrue(FRedis.BLPOP(['mylist'], 1, ArrRes));
  CheckEquals('mylist', ArrRes[0]);
  CheckEquals('two', ArrRes[1]);

  // pop from a empty list, check the timeout
  CheckFalse(FRedis.BLPOP(['mylist'], 1, ArrRes));
  CheckEquals(0, Length(ArrRes));

  // now, test if it works when another thread pushes a values into the list
  TThread.CreateAnonymousThread(
    procedure
    var
      Redis: IRedisClient;
    begin
      Redis := NewRedisClient('localhost');
      Redis.RPUSH('mylist', ['from', 'another', 'thread']);
    end).Start;

  CheckTrue(FRedis.BLPOP(['mylist'], 10, ArrRes));
  CheckEquals(2, Length(ArrRes));
end;

procedure TestRedisClient.TestBRPOP;
begin
  // setup list
  FRedis.DEL(['mylist']);
  FRedis.RPUSH('mylist', ['one', 'two']);

  // pop from a non-empty list
  CheckTrue(FRedis.BRPOP(['mylist'], 1, ArrRes));
  CheckEquals('mylist', ArrRes[0]);
  CheckEquals('two', ArrRes[1]);

  // pop from a non-empty list
  CheckTrue(FRedis.BRPOP(['mylist'], 1, ArrRes));
  CheckEquals('mylist', ArrRes[0]);
  CheckEquals('one', ArrRes[1]);

  // pop from a empty list, check the timeout
  CheckFalse(FRedis.BRPOP(['mylist'], 1, ArrRes));
  CheckEquals(0, Length(ArrRes));

  // now, test if it works when another thread pushes a values into the list
  TThread.CreateAnonymousThread(
    procedure
    var
      Redis: IRedisClient;
    begin
      Redis := NewRedisClient('localhost');
      Redis.RPUSH('mylist', ['from', 'another', 'thread']);
    end).Start;

  CheckTrue(FRedis.BRPOP(['mylist'], 10, ArrRes));
  CheckEquals(2, Length(ArrRes));
end;

procedure TestRedisClient.TestBRPOPLPUSH;
var
  Value: string;
begin
  FRedis.DEL(['mylist', 'myotherlist']);
  CheckFalse(FRedis.BRPOPLPUSH('mylist', 'myotherlist', Value, 1));
  CheckEquals('', Value);
  FRedis.RPUSH('mylist', ['one', 'two']);

  CheckTrue(FRedis.BRPOPLPUSH('mylist', 'myotherlist', Value, 1));
  CheckEquals('two', Value);
  CheckTrue(FRedis.RPOP('myotherlist', Value));
  CheckEquals('two', Value);

  CheckTrue(FRedis.BRPOPLPUSH('mylist', 'myotherlist', Value, 1));
  CheckEquals('one', Value);
  CheckTrue(FRedis.RPOP('myotherlist', Value));
  CheckEquals('one', Value);

  CheckFalse(FRedis.BRPOPLPUSH('mylist', 'myotherlist', Value, 1));
  CheckEquals('', Value);
end;

procedure TestRedisClient.TestCommandParser;
  procedure CheckSimpleSet;
  begin
    CheckEquals('set', ArrRes[0]);
    CheckEquals('nome', ArrRes[1]);
    CheckEquals('daniele', ArrRes[2]);
  end;

  procedure CheckSimpleSet2;
  begin
    CheckEquals('set', ArrRes[0]);
    CheckEquals('no me', ArrRes[1]);
    CheckEquals('da ni\ele', ArrRes[2]);
  end;

begin
  ArrRes := FRedis.Tokenize('set nome daniele');
  CheckSimpleSet;
  ArrRes := FRedis.Tokenize('set    nome  daniele');
  CheckSimpleSet;
  ArrRes := FRedis.Tokenize('   set    "nome"    daniele   ');
  CheckSimpleSet;
  ArrRes := FRedis.Tokenize('   set    "nome"    "daniele"   ');
  CheckSimpleSet;
  ArrRes := FRedis.Tokenize('set  nome "daniele"');
  CheckSimpleSet;
  ArrRes := FRedis.Tokenize('set  "no me" "da ni\ele"');
  CheckSimpleSet2;
  ExpectedException := ERedisException;
  ArrRes := FRedis.Tokenize('set nome "daniele');
end;

procedure TestRedisClient.TestDelete;
begin
  FRedis.&SET('NOME', 'Daniele');
  FRedis.&SET('COGNOME', 'Teti');
  CheckEquals(1, FRedis.DEL(['NOME']));
  CheckFalse(FRedis.GET('NOME', Res));
  CheckTrue(FRedis.GET('COGNOME', Res));
end;

procedure TestRedisClient.TestExecuteWithStringArrayResponse;
var
  Cmd: IRedisCommand;
begin
  FRedis.FLUSHDB;
  Cmd := NewRedisCommand('keys');
  Cmd.Add('*o*');
  CheckEquals(0, Length(FRedis.ExecuteAndGetArray(Cmd)));
  FRedis.&SET('1one', '1');
  FRedis.&SET('2one', '2');
  CheckEquals(2, Length(FRedis.ExecuteAndGetArray(Cmd)));
end;

procedure TestRedisClient.TestEXPIRE;
var
  v: string;
begin
  FRedis.&SET('daniele', '1234');
  FRedis.EXPIRE('daniele', 1);
  FRedis.GET('daniele', v);
  CheckEquals('1234', v);
  TThread.Sleep(1100);
  CheckFalse(FRedis.GET('daniele', v));
end;

procedure TestRedisClient.TestGETRANGE;
begin
  FRedis.DEL(['mykey']);
  CheckEquals('', FRedis.GETRANGE('mykey', 0, 1));
  FRedis.&SET('mykey', '0123456789');
  CheckEquals('0', FRedis.GETRANGE('mykey', 0, 0));
  CheckEquals('01', FRedis.GETRANGE('mykey', 0, 1));
  CheckEquals('12', FRedis.GETRANGE('mykey', 1, 2));
  CheckEquals('0123456789', FRedis.GETRANGE('mykey', 0, -1));
  CheckEquals('456789', FRedis.GETRANGE('mykey', 4, -1));
  CheckEquals('45678', FRedis.GETRANGE('mykey', 4, -2));
  CheckEquals('', FRedis.GETRANGE('mykey', 4, 2));
end;

procedure TestRedisClient.TestHMGetBUGWithEmptyValues;
var
  Values: TArray<string>;
begin
  FRedis.HSET('abc', 'Name', 'Daniele Teti');
  FRedis.HSET('abc', 'Address', '');
  FRedis.HSET('abc', 'Postcode', '12345');
  // there was an access violation here
  Values := FRedis.HMGET('abc', ['Name', 'Address', 'Postcode']);
  CheckEquals('Daniele Teti', Values[0]);
  CheckEquals('', Values[1]);
  CheckEquals('12345', Values[2]);
end;

procedure TestRedisClient.TestHMSetHMGet;
const
  C_KEY = 'thekey';
var
  lValues: TArray<string>;
begin
  FRedis.DEL([C_KEY]);
  FRedis.HMSET(C_KEY, ['field1', 'field2', 'field3'],
    ['value1', 'value2', 'value3']);
  lValues := FRedis.HMGET(C_KEY, ['field1', 'field2', 'field3']);

  CheckEqualsString('value1', lValues[0]);
  CheckEqualsString('value2', lValues[1]);
  CheckEqualsString('value3', lValues[2]);
end;

procedure TestRedisClient.TestHSetHGet;
var
  aResult: string;
begin
  FRedis.DEL(['mykey']);
  FRedis.HSET('mykey', 'first_name', 'Daniele');
  FRedis.HSET('mykey', 'last_name', 'Teti');
  FRedis.HGET('mykey', 'first_name', aResult);
  CheckEqualsString('Daniele', aResult);
  FRedis.HGET('mykey', 'last_name', aResult);
  CheckEqualsString('Teti', aResult);
end;

procedure TestRedisClient.TestHSetHGet_Bytes;
const
  C_KEY = 'mykey';
  C_field = 'name';
  C_VALUE = 'Daniele';
var
  aResult: Tbytes;
begin
  FRedis.DEL([C_KEY]);
  FRedis.HSET(C_KEY, C_field, C_VALUE);
  FRedis.HGET(C_KEY, C_field, aResult);
  CheckEqualsString(C_VALUE, StringOf(aResult));
end;

procedure TestRedisClient.TestINCR_DECR;
begin
  FRedis.&SET('daniele', '-1');
  CheckEquals(0, FRedis.INCR('daniele'));
  FRedis.&SET('daniele', '1');
  CheckEquals(2, FRedis.INCR('daniele'));
  CheckEquals(1, FRedis.DECR('daniele'));
  FRedis.DEL(['daniele']);
  CheckEquals(-1, FRedis.DECR('daniele'));
end;

procedure TestRedisClient.TestLLEN;
begin
  FRedis.DEL(['mylist']);
  CheckEquals(0, FRedis.LLEN('mylist'));

  FRedis.RPUSH('mylist', ['one', 'two']);
  CheckEquals(2, FRedis.LLEN('mylist'));

  FRedis.&SET('myvalue', '3');
  ExpectedException := ERedisException;
  FRedis.LLEN('myvalue');
end;

procedure TestRedisClient.TestLPUSH_LPOP;
var
  Value: string;
begin
  FRedis.DEL(['mylist']);
  FRedis.LPUSH('mylist', ['one', 'two', 'three']);

  CheckTrue(FRedis.LPOP('mylist', Value));
  CheckEquals('three', Value);

  CheckTrue(FRedis.LPOP('mylist', Value));
  CheckEquals('two', Value);

  CheckTrue(FRedis.LPOP('mylist', Value));
  CheckEquals('one', Value);

  CheckFalse(FRedis.LPOP('mylist', Value))
end;

procedure TestRedisClient.TestLRANGE;
begin
  FRedis.DEL(['mylist']);
  FRedis.RPUSH('mylist', ['one', 'two', 'three', 'four', 'five']);
  ArrRes := FRedis.LRANGE('mylist', 0, 1);
  CheckEquals(2, Length(ArrRes));
  CheckEquals('one', ArrRes[0]);
  CheckEquals('two', ArrRes[1]);

  ArrRes := FRedis.LRANGE('mylist', -1, -1);
  CheckEquals(1, Length(ArrRes));
  CheckEquals('five', ArrRes[0]);

  ArrRes := FRedis.LRANGE('mylist', 0, 20);
  CheckEquals(5, Length(ArrRes));
  CheckEquals('one', ArrRes[0]);
  CheckEquals('two', ArrRes[1]);
  CheckEquals('three', ArrRes[2]);
  CheckEquals('four', ArrRes[3]);
  CheckEquals('five', ArrRes[4]);

  ArrRes := FRedis.LRANGE('notexists', 0, 20);
  CheckEquals(0, Length(ArrRes));
end;

procedure TestRedisClient.TestLREM;
begin
  FRedis.DEL(['mylist']);
  FRedis.RPUSH('mylist', ['hello', 'hello', 'foo', 'hello']);
  FRedis.LREM('mylist', -2, 'hello');
  ArrRes := FRedis.LRANGE('mylist', 0, -1);
  CheckEquals('hello', ArrRes[0]);
  CheckEquals('foo', ArrRes[1]);
end;

procedure TestRedisClient.TestLTRIM;
begin
  FRedis.DEL(['mylist']);
  CheckEquals(0, FRedis.LLEN('mylist'));

  FRedis.RPUSH('mylist', ['one', 'two', 'three', 'four', 'five']);
  CheckEquals(5, FRedis.LLEN('mylist'));

  FRedis.LTRIM('mylist', 0, 2);
  CheckEquals(3, FRedis.LLEN('mylist'));

  FRedis.LTRIM('mylist', 1, -2);
  CheckEquals(1, FRedis.LLEN('mylist'));

  FRedis.LTRIM('mylist', 10, -10);
  CheckEquals(0, FRedis.LLEN('mylist'));
end;

procedure TestRedisClient.TestMSET;
begin
  FRedis.FLUSHDB;
  CheckTrue(FRedis.MSET(['one', '1', 'two', '2', 'three', '3']));
  ArrRes := FRedis.KEYS('*e*');
  CheckEquals(2, Length(ArrRes));
end;

procedure TestRedisClient.TestMULTI;
var
  v: string;
begin
  ArrRes := FRedis.MULTI(
    procedure(const Redis: IRedisClient)
    begin
      Redis.&SET('name', 'Daniele');
      Redis.DEL(['name']);
    end);
  CheckEquals('OK', ArrRes[0]);
  CheckEquals('1', ArrRes[1]);
  CheckFalse(FRedis.GET('name', v));
end;

procedure TestRedisClient.TestRPOPLPUSH;
var
  Value: string;
begin
  FRedis.DEL(['mylist', 'myotherlist']);
  CheckFalse(FRedis.RPOPLPUSH('mylist', 'myotherlist', Value));
  CheckEquals('', Value);
  FRedis.RPUSH('mylist', ['one', 'two']);

  CheckTrue(FRedis.RPOPLPUSH('mylist', 'myotherlist', Value));
  CheckEquals('two', Value);
  CheckTrue(FRedis.RPOP('myotherlist', Value));
  CheckEquals('two', Value);

  CheckTrue(FRedis.RPOPLPUSH('mylist', 'myotherlist', Value));
  CheckEquals('one', Value);
  CheckTrue(FRedis.RPOP('myotherlist', Value));
  CheckEquals('one', Value);

  CheckFalse(FRedis.RPOPLPUSH('mylist', 'myotherlist', Value));
  CheckEquals('', Value);
end;

procedure TestRedisClient.TestRPUSHX_LPUSHX;
begin
  FRedis.DEL(['mylist']);
  // mylist doesn't exists, so RPUSHX doesn't create it.
  CheckEquals(0, FRedis.RPUSHX('mylist', ['one']));
  CheckEquals(0, FRedis.LLEN('mylist'));

  // RPUSH creates mylist
  CheckEquals(1, FRedis.RPUSH('mylist', ['one']));
  CheckEquals(1, FRedis.LLEN('mylist'));

  // RPUSHX append to the list
  CheckEquals(2, FRedis.RPUSHX('mylist', ['two']));

  FRedis.DEL(['mylist']);
  CheckEquals(0, FRedis.LPUSHX('mylist', ['one']));
  CheckEquals(0, FRedis.LLEN('mylist'));
end;

procedure TestRedisClient.TestRPUSH_RPOP;
var
  Value: string;
begin
  FRedis.DEL(['mylist']);
  FRedis.RPUSH('mylist', ['one', 'two', 'three']);

  CheckTrue(FRedis.RPOP('mylist', Value));
  CheckEquals('three', Value);

  CheckTrue(FRedis.RPOP('mylist', Value));
  CheckEquals('two', Value);

  CheckTrue(FRedis.RPOP('mylist', Value));
  CheckEquals('one', Value);

  CheckEquals(False, FRedis.RPOP('mylist', Value));
end;

procedure TestRedisClient.TestSELECT;
var
  v: string;
begin
  FRedis.SELECT(0);
  FRedis.&SET('db0', 'value0');
  FRedis.SELECT(1);
  CheckFalse(FRedis.GET('db0', v));
  FRedis.SELECT(0);
  FRedis.GET('db0', v);
  CheckEquals('value0', v);
end;

procedure TestRedisClient.TestSetGet;
var
  Res: string;
begin
  CheckTrue(FRedis.&SET('nome', 'Daniele'));
  FRedis.GET('nome', Res);
  CheckEquals('Daniele', Res);

  CheckTrue(FRedis.&SET('no"me', 'Dan"iele'));
  CheckTrue(FRedis.GET('no"me', Res));
  CheckEquals('Dan"iele', Res);

  CheckTrue(FRedis.&SET('no"me', 'Dan iele'));
  CheckTrue(FRedis.GET('no"me', Res));
  CheckEquals('Dan iele', Res);
end;

procedure TestRedisClient.TestSetGetUnicode;
var
  Res: string;
const
  NonStdASCIIValue = 'אטילעשח@§°`';
begin
  CheckTrue(FRedis.&SET('nome', NonStdASCIIValue));
  CheckTrue(FRedis.GET('nome', Res));
  CheckEquals(NonStdASCIIValue, Res);
end;

procedure TestRedisClient.TestSETRANGE;
var
  lValue: string;
  lBytesValue: TArray<Byte>;
begin
  FRedis.&SET('mykey', '00112233445566778899');
  CheckEquals(20, FRedis.SETRANGE('mykey', 0, 'XX'));
  FRedis.GET('mykey', lValue);
  CheckEquals('XX112233445566778899', lValue);

  FRedis.&SET('mykey', '00112233445566778899');
  CheckEquals(20, FRedis.SETRANGE('mykey', 2, 'XX'));
  FRedis.GET('mykey', lValue);
  CheckEquals('00XX2233445566778899', lValue);

  FRedis.&SET('mykey', '00112233445566778899');
  CheckEquals(20, FRedis.SETRANGE('mykey', 18, 'XX'));
  FRedis.GET('mykey', lValue);
  CheckEquals('001122334455667788XX', lValue);

  FRedis.DEL(['mykey']);
  CheckEquals(4, FRedis.SETRANGE('mykey', 2, 'XY'));
  FRedis.GET('mykey', lBytesValue);

  CheckEquals('00', ByteToHex(lBytesValue[0])); // padded bytes are $00
  CheckEquals('00', ByteToHex(lBytesValue[1])); // padded bytes are $00
  CheckEquals(IntToHex(Ord('X'), 2), ByteToHex(lBytesValue[2]));
  CheckEquals(IntToHex(Ord('Y'), 2), ByteToHex(lBytesValue[3]));
end;

procedure TestRedisClient.TestSTRLEN;
begin
  FRedis.DEL(['mykey']);
  CheckEquals(0, FRedis.STRLEN('mykey'), 'Len of a not exists key is not zero');
  FRedis.APPEND('mykey', '1234');
  CheckEquals(4, FRedis.STRLEN('mykey'), 'Wrong length');
  FRedis.APPEND('mykey', '5678');
  CheckEquals(8, FRedis.STRLEN('mykey'), 'Wrong length');
end;

procedure TestRedisClient.TestWATCH_Fail;
var
  lValue: string;
  lOtherClient: IRedisClient;
begin
  lOtherClient := NewRedisClient;
  FRedis.&SET('mykey', '1234');
  FRedis.WATCH(['mykey']);
  FRedis.GET('mykey', lValue);
  lOtherClient.&SET('mykey', '1111'); // another client change the watched key!
  ExpectedException := ERedisException;
  FRedis.MULTI(
    procedure(const R: IRedisClient)
    begin
      R.&SET('mykey', IntToStr(StrToInt(lValue) + 1));
    end);
end;

procedure TestRedisClient.TestWATCH_MULTI_EXEC_OK;
var
  lValue: string;
  lResp: TArray<string>;
begin
  FRedis.&SET('mykey', '1234');
  FRedis.WATCH(['mykey']);
  FRedis.GET('mykey', lValue);
  FRedis.MULTI;
  CheckTrue(FRedis.InTransaction, 'Is not in transaction when it should');
  FRedis.&SET('mykey', IntToStr(StrToInt(lValue) + 1));
  lResp := FRedis.EXEC;
  Check(Length(lResp) = 1);
  Check(lResp[0] = 'OK');
  CheckFalse(FRedis.InTransaction, 'Is in transaction when it should not');
end;

procedure TestRedisClient.TestWATCH_MULTI_EXEC_Fail;
var
  lValue: string;
  lOtherClient: IRedisClient;
begin
  lOtherClient := NewRedisClient;
  FRedis.&SET('mykey', '1234');
  FRedis.WATCH(['mykey']);
  FRedis.GET('mykey', lValue);
  lOtherClient.&SET('mykey', '1111'); // this invalidate the transaction
  FRedis.MULTI;
  CheckTrue(FRedis.InTransaction, 'Is not in transaction when it should');
  FRedis.&SET('mykey', IntToStr(StrToInt(lValue) + 1));
  try
    FRedis.EXEC;
    fail('No exception efter EXEC');
  except
    on E: Exception do
    begin
      CheckInherits(ERedisException, E.ClassType);
    end;
  end;
  CheckFalse(FRedis.InTransaction, 'Is in transaction when it should not');
end;

procedure TestRedisClient.TestWATCH_OK;
var
  lValue: string;
  lOtherClient: IRedisClient;
begin
  lOtherClient := NewRedisClient;
  FRedis.&SET('mykey', '1234');
  FRedis.WATCH(['mykey']);
  FRedis.GET('mykey', lValue);
  FRedis.MULTI(
    procedure(const R: IRedisClient)
    begin
      R.&SET('mykey', IntToStr(StrToInt(lValue) + 1));
    end);
end;

procedure TestRedisClient.TestZADD_ZRANK_ZCARD;
var
  lValue: Int64;
begin
  FRedis.DEL(['myset']);
  FRedis.ZADD('myset', 1, 'one');
  FRedis.ZADD('myset', 2, 'two');
  FRedis.ZADD('myset', 3, 'three');
  FRedis.ZADD('myset', 4, 'four');
  FRedis.ZADD('myset', 5, 'five');

  CheckEquals(5, FRedis.ZCARD('myset'));
  CheckEquals(0, FRedis.ZCARD('notexists'));

  CheckFalse(FRedis.ZRANK('myset', 'notexists', lValue));

  CheckTrue(FRedis.ZRANK('myset', 'one', lValue));
  CheckEquals(0, lValue);

  CheckTrue(FRedis.ZRANK('myset', 'two', lValue));
  CheckEquals(1, lValue);

  CheckTrue(FRedis.ZRANK('myset', 'three', lValue));
  CheckEquals(2, lValue);

  CheckTrue(FRedis.ZRANK('myset', 'four', lValue));
  CheckEquals(3, lValue);

  CheckTrue(FRedis.ZRANK('myset', 'five', lValue));
  CheckEquals(4, lValue);

end;

// procedure TestRedisClient.TestSUBSCRIBE;
// var
// Rcv: NativeInt;
// MSG: string;
// X: NativeInt;
// begin
// //not implemented
// {
// AtomicExchange(Rcv, 0);
// // It's used for immediate real-time messaging, not for history storage
// FRedis.SUBSCRIBE(['ch1', 'ch2'],
// procedure(Channel, Message: string)
// begin
// MSG := message;
// AtomicIncrement(Rcv, 1);
// end);
// }
// {
// while true do
// begin
// X := AtomicCmpExchange(Rcv, -1, -1);
// TThread.Sleep(100)
// end;
// CheckEquals('hello', MSG);
// }
// end;

initialization

// Register any test cases with the test runner
RegisterTest(TestRedisClient.Suite);

end.
